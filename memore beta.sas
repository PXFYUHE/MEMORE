
* MEMORE for SAS Beta Release;
* Copyright 2015;
* by Amanda K. Montoya and Andrew F Hayes;
* www.afhayes.com;

* Permission is hereby granted, free of charge, to any person obtaining a copy of this software;
* and associated documentation files (the "Software"), to use the software in this form.  Distribution;
* after modification is prohibited, as is its use for any commercial purpose without authorization;  
* This software should not be posted or stored on any webpage, server, or directory accessible to;
* the public whether free or for a charge unless written permission has been granted by the copyright;
* holder.  The copyright holder requests that this software be distributed by directing users to;
* afhayes.com where the latest release of the software and related documentation is archived and;
* can be downloaded;

* THIS SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, ;
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF ;
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT ;
* IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, ;
* DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT ;
* OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE ;
* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE ;

* The above text should be included in any distribution of the software;


%macro cdfinvt (p=,df=);
p0=-.322232431088;p1=-1;p2=-.342242088547;p3=-.0204231210245;p4=-.0000453642210148;
q0=.0993484626060;q1=.588581570495;q2=.531103462366;q3=.103537752850;q4=.0038560700634;
ppv=&p;if (&p > .5) then;do;ppv=1-&p;end;
y5=sqrt(-2*log(ppv));
xp=y5+((((y5*p4+p3)*y5+p2)*y5+p1)*y5+p0)/((((y5*q4+q3)*y5+q2)*y5+q1)*y5+q0);
if (&p <= .5) then;do;xp=-xp;end;
toutput=sqrt(&df*(exp((&df-(5/6))*(xp##2)/(&df-(2/3)+.11/&df)##2)-1));
%mend;

%macro memore (data=,y=,m=,conf=95,mc=0,samples=5000,normal=0,bc=0,decimals=10.4,
  save=xxx,seed=0,contrast=0);
options pagesize=32767;
proc iml;
runnotes=j(11,1,0);
criterr=0;
use &data;
read all var{&m &y} into data;
ynames={&y};mnames={&m};names={&m &y};
ninit=nrow(data);
xx=(data = .);xx=xx[,+];
j=1;do i=1 to nrow(data);if xx[i,1]=0 then;do;data[j,]=data[i,];j=j+1;end;end;
data=data[1:j-1,];
mc = (&mc = 1); 
missing=ninit-nrow(data);
if (missing > 0) then;do;runnotes[1,1]=1;end;
if (ncol(ynames) ^= 2) then;do;runnotes[2,1]=2;criterr=1;end;
mcount=ncol(mnames);
if ("&save" = "") then saveboot="xxx";else saveboot="&save";
if (((mcount < 2) | ((mcount/2) ^= floor(mcount/2)) | (mcount > 20)) & (criterr ^= 2)) then;do;
  runnotes[6,1]=6;criterr=1;
end;

if (criterr = 0) then;do;
  do i = 1 to mcount;
    if ((mnames[1,i]=ynames[1,1]) | (mnames[1,i]=ynames[1,2]) | (ynames[1,1]=ynames[1,2])) then;do;
      runnotes[8,1]=8;criterr=1;
    end;
  end;
end;

zero=j(nrow(data),1,0);
do i = 1 to (ncol(data)-1) by 2;
  diff=data[,i]-data[,(i+1)];
  copy=(diff=zero);copy=copy[+];
  if (copy=nrow(data)) then;do;
    copyname=names[1,i]||names[1,(i+1)];
	runnotes[7,1]=7;criterr=1;
  end;
end;


if (&samples = 0) then;do;
  samples=5000;mc=1;
end;
if (&samples ^=0) then;do;
  samples=abs(floor(&samples))*(abs(floor(&samples))>=1000)+5000*(abs(floor(&samples))<1000);
end;
if (samples ^= &samples) then;do;
  runnotes[3,1]=3;
end;


conf=&conf;if ((&conf < 50) | (&conf > 99.99)) then;do;conf=95;runnotes[5,1]=5;end;

bc=floor(&bc);
if ((mc=1) & (bc=1)) then;do;runnotes[9,1]=9;bc=0;end;

if ((&contrast=1) & ((mcount/2)=1)) then;do;runnotes[10,1]=10;end;

savboot=0;
  if ((saveboot ^= "xxx") & (samples > 0)) then;do;savboot=1;
end;

if (criterr=0) then;do; *1;
  mpairs=mcount/2;
  mnamemat=shape(mnames,mpairs,2);
  n=nrow(data);
  transmat={1 0.5, -1 0.5};
  tmat=j(ncol(data),ncol(data),0);
  do i = 1 to (2*mpairs+1) by 2;
    tmat[i:(i+1),i:(i+1)]=transmat;
  end;
  datat=data*tmat;
  aresmat=j(mpairs,7,0);
  ghostdes=j(n,1,1);
  alpha=(1-.01*conf);
  temp=alpha/2;
  %cdfinvt (p=temp,df=(n-1));
  tcrita=toutput;
  tcritc=toutput;
  
  do j=1 to mpairs;
    summean=datat[,(2*j)];summean=summean[+,]/n;
    datat[,(2*j)]=(datat[,(2*j)]-summean);
	apath=inv(ghostdes`*ghostdes)*ghostdes`*datat[,(2*j-1)];
	tempmn=datat[,(2*j-1)];tempmn=tempmn[+,]/n;
	tempsm=datat[,(2*j-1)]-tempmn;tempsm=tempsm#tempsm;tempsm=tempsm[+,]/(n-1);
	semdiff=sqrt(tempsm/n);
    tapath=apath/semdiff;
	dfapath=n-1;
	papath=2*(1-probt(abs(tapath),dfapath));
	lcia=apath-tcrita*semdiff;
	ucia=apath+tcrita*semdiff;
	aresmat[j,]=apath||semdiff||tapath||dfapath||papath||lcia||ucia;
  end;

  cpath=inv(ghostdes`*ghostdes)*ghostdes`*datat[,(2*mpairs+1)];
  tempmn=datat[,(2*mpairs+1)];tempmn=tempmn[+,]/n;
  tempsm=datat[,(2*mpairs+1)]-tempmn;tempsm=tempsm#tempsm;tempsm=tempsm[+,]/(n-1);
  seydiff=sqrt(tempsm/n);
  tcpath=cpath/seydiff;
  dfcpath=n-1;
  pcpath=2*(1-probt(abs(tcpath),dfcpath));
  lcic=cpath-tcritc*seydiff;
  ucic=cpath+tcritc*seydiff;
  cresmat=cpath||seydiff||tcpath||dfcpath||pcpath||lcic||ucic;

  bcpdes=j(n,1,1)||datat[,1:(ncol(datat)-2)];
  bcpvec=inv(bcpdes`*bcpdes)*bcpdes`*datat[,(ncol(datat)-1)];
  ypred=bcpdes*bcpvec;
  ssr=(datat[,(ncol(datat)-1)]-ypred)##2;ssr=ssr[+,];
  tempmn=datat[,(ncol(datat)-1)];tempmn=tempmn[+,]/n;
  sst=(datat[,(ncol(datat)-1)]-tempmn)##2;sst=sst[+,];
  msr=ssr/(n-ncol(bcpdes));
  rsqfull=1-ssr/sst;
  rfull=sqrt(rsqfull);
  df1=ncol(bcpdes)-1;df2=n-ncol(bcpdes);
  Ffull=(df2*rsqfull)/(df1*(1-rsqfull));
  pfull=1-probf(Ffull,df1,df2);
  sebcpmat=msr*inv(bcpdes`*bcpdes);
  sebcp=sqrt(vecdiag(sebcpmat));

  bresmat=j(mpairs,7,0);dresmat=j(mpairs,7,0);indres=j((mpairs+1),1,0);
  if (&normal=1) then;do;
    normres=j(mpairs,4,0);
  end;

  %cdfinvt (p=temp,df=df2);
  tcritb=toutput;tcritcp=toutput;tcritd=toutput;

  cppath=bcpvec[1,1];
  secppath=sebcp[1,1];
  tcppath=cppath/secppath;
  pcppath=2*(1-probt(abs(tcppath),df2));
  lcicp=cppath-tcritcp*secppath;
  ucicp=cppath+tcritcp*secppath;
  cpresmat=cppath||secppath||tcppath||df2||pcppath||lcicp||ucicp;

  lcii=floor((1-.01*conf)/2*samples);
  ucii=floor((1-((1-.01*conf)/2))*samples)+1;
  if ((lcii < 1) | (ucii > samples)) then; do;runnotes[4,1]=4;criterr=1;lcii=1;ucii=samples;end;
  
  if (mc = 1) then;do;
    mcsamps=samples;
    randsamp=sqrt(-2*log(ranuni(j(mcsamps,mpairs,&seed))))#cos((2*3.14159265358979)*(ranuni(j(mcsamps,mpairs))));
	mcres=j(mpairs+1,4,0);
	mccorr=j(mpairs,mpairs,1);
	do i = 1 to mpairs;
	  mccorr[i,i]=sebcpmat[(2*i),(2*i)];
	  if ((mpairs > 1) & (i ^= mpairs)) then;do;
	    do j=(i+1) to mpairs;
		  mccorr[i,j]=sebcpmat[(2*i),(2*j)];
		  mccorr[j,i]=sebcpmat[(2*i),(2*j)];
		end;
	  end;
	end;
	rndnb=randsamp*root(mccorr);
    rndna=sqrt(-2*log(ranuni(j(mcsamps,mpairs))))#cos((2*3.14159265358979)*(ranuni(j(mcsamps,mpairs))));
    mcsave=j(samples,(3*mpairs+1),0);
	mcsave2=j(samples,mpairs,0);
  end;

  do i = 1 to mpairs;
    bpath=bcpvec[(2*i),1];sebpath=sebcp[(2*i),1];
	tbpath=bpath/sebpath;
	pbpath=2*(1-probt(abs(tbpath),df2));
	lcib=bpath-tcritb*sebpath;
	ucib=bpath+tcritb*sebpath;
	bresmat[i,]=bpath||sebpath||tbpath||df2||pbpath||lcib||ucib;
	dpath=bcpvec[((2*i)+1),1];
	sedpath=sebcp[((2*i)+1),1];
	tdpath=dpath/sedpath;
	pdpath=2*(1-probt(abs(tdpath),df2));
	lcid=dpath-tcritd*sedpath;
	ucid=dpath+tcritd*sedpath;
	dresmat[i,]=dpath||sedpath||tdpath||df2||pdpath||lcid||ucid;
	indirect=aresmat[i,1]*bresmat[i,1];
	indres[i,1]=indirect;
	if (&normal = 1) then;do;
      sobseab=sqrt(((aresmat[i,1]##2)*(bresmat[i,2]##2))+((bresmat[i,1]##2)*(aresmat[i,2]##2)));
	  sobelz=indirect/sobseab;
	  sobelp=2*(probnorm(-abs(sobelz)));
	  normres[i,]=indirect||sobseab||sobelz||sobelp;
	end;

	if (mc = 1) then;do;
      asamp=rndna[,i]*aresmat[i,2]+aresmat[i,1];
	  bsamp=rndnb[,i]+bresmat[i,1];
	  absamp=asamp#bsamp;
      mcgrad=rank(absamp);
	  mcsort=absamp;
	  mcsort[mcgrad]=absamp;
	  mcsave[,(3*i-2):(3*i)]=asamp||bsamp||absamp;
	  mcsave2[,i]=absamp;
	  mcllci=mcsort[lcii,1];
	  mculci=mcsort[ucii,1];
      tempmn=mcsort[+,]/mcsamps;
      tempsm=(mcsort[,1]-tempmn)##2;semc=sqrt(tempsm[+,]/(mcsamps-1));
	  mcres[i,]=indirect||semc||mcllci||mculci;
	end;
  end;

  if (mc = 1) then;do;
    mcsave[,3*mpairs+1]=mcsave2[,+];
	mcsort=mcsave[,3*mpairs+1];
    mcgrad=rank(mcsort);
    mcsort2=mcsort;
	mcsort2[mcgrad]=mcsort;
	mcsort=mcsort2;
	mcllci=mcsort[lcii];mculci=mcsort[ucii];
    tempmn=mcsort[+,]/mcsamps;
    tempsm=(mcsort[,1]-tempmn)##2;semc=sqrt(tempsm[+,]/(mcsamps-1));
	mcres[mpairs+1,]=indres[+,]||semc||mcllci||mculci;
	if ((&contrast=1) & (mpairs > 1)) then;do;
      npairs = Mpairs*(Mpairs-1)/2; 
	  contres=j(npairs,4,0);
	  contsamp=j(samples,npairs,0);
	  contsort=contsamp;
	  counter=1;
	  do i = 1 to mpairs-1;
	    do j = (i+1) to mpairs;
		  contsamp[,counter]=mcsave2[,i]-mcsave2[,j];
		  contres[counter,1]=indres[i,1]-indres[j,1];
		  tttt=contsamp[,counter];
          tempmn=tttt[+,]/mcsamps;
          tempsm=(tttt[,1]-tempmn)##2;
          contres[counter,2]=sqrt(tempsm[+,]/(mcsamps-1));
          contgrad=rank(tttt);
		  contsort[contgrad,counter]=tttt;
          contres[counter,3]=contsort[lcii,counter];
		  contres[counter,4]=contsort[ucii,counter];
		  counter=counter+1;
		end;
	  end;
	end;
  end;

  if (mc ^= 1) then;do;
    bootsamp=j(samples,mpairs+1,0);
	bootsave=j(samples,3*Mpairs+3,0);
	indtemp=j(samples,mpairs,0);
	do i = 1 to samples;
	  sortvar=floor((ranuni(j(n,1,&seed)))*n)+1;
      bootdat=datat[sortvar,];
	  do j = 1 to mpairs;
        tempmn=bootdat[,2*j];tempmn=tempmn[+,]/n;
	    bootdat[,2*j]=bootdat[,2*j]-tempmn;
	  end;
	  bootdes=j(n,1,1)||bootdat[,1:(ncol(bootdat)-2)];
	  bootbeta=inv(bootdes`*bootdes)*bootdes`*bootdat[,ncol(bootdat)-1];
	  do j = 1 to mpairs;
        boota=inv(ghostdes`*ghostdes)*ghostdes`*bootdat[,(2*j-1)];
	    bootb=bootbeta[2*j,1];
	    bootsamp[i,j]=bootb*boota;
        bootsave[i,(3*j-2):(3*j)]=boota||bootb||boota*bootb;
		indtemp[i,j]=boota*bootb;
	  end;
	  bootsave[i,3*mpairs+2]=bootbeta[1,1];
	  tempsm=indtemp[i,];
	  bootsave[i,3*mpairs+3]=tempsm[,+]+bootbeta[1,1];
    end;
    if ((&contrast = 1) & (mpairs > 1)) then;do;
      npairs = Mpairs*(Mpairs-1)/2;
	  contres=j(npairs,4,0);
	  contsamp=j(samples,npairs,0);
	  counter=1;
	  do i = 1 to mpairs-1;
	    do j = i+1 to mpairs;
		contsamp[,counter]=indtemp[,i]-indtemp[,j];
		contres[counter,1]=indres[i,1]-indres[j,1];
		counter=counter+1;
		end;
	  end;
	end;
	tempsm=bootsamp[,1:mpairs];
    bootsamp[,mpairs+1]=tempsm[,+];
	bootsave[,3*mpairs+1]=tempsm[,+];
	indres[mpairs+1,1]=indres[+,];
	bootsort=bootsamp;
	seboots=j(mpairs+1,1,0);
	bccires=j(4,mpairs+1,0);
	bootllci=j(1,ncol(bootsamp),0);
	bootulci=j(1,ncol(bootsamp),0);
    zalpha2=sqrt(-2*log(alpha/2));
    zalpha2=(zalpha2+((((zalpha2*p4+p3)*zalpha2+p2)*zalpha2+p1)*zalpha2+p0)/((((zalpha2*q4+q3)*zalpha2+q2)*zalpha2+q1)*zalpha2+q0));
    do i = 1 to ncol(bootsamp); *3;
	  tttt=bootsamp[,i];
      bootgrad=rank(tttt);
      bootsort[bootgrad,i]=tttt;
      tempmn=tttt[+,]/samples;
      tempsm=(tttt[,1]-tempmn)##2;
      seboots[i,1]=sqrt(tempsm[+,]/(samples-1));
	  bootsam2=indres[i,1]//bootsamp[,i];
      bootgra2=rank(bootsam2);
	  if (bc=1) then;do;
	    ttttt=bootsamp[,i];
        tttt=(ttttt < indres[i,1]);bccires[1,i]=tttt[+,]/samples;
        bccires[2,i]=bccires[1,i];
        if (bccires[1,i] > .5) then;do;bccires[2,i]=1-bccires[1,i];end;
		bccires[3,i]=sqrt(-2*log(bccires[2,i]));
		tttt=bccires[3,i];
        bccires[4,i]=tttt+((((tttt*p4+p3)*tttt+p2)*tttt+p1)*tttt+p0)/((((tttt*q4+q3)*tttt+q2)*tttt+q1)*tttt+q0);
        if (bccires[1,i] <= .5) then;do;
		  bccires[4,i]=-bccires[4,i];
		end;
        bcllii=probnorm(2*bccires[4,i]-zalpha2)*samples;
		bcucii=probnorm(2*bccires[4,i]+zalpha2)*samples;
		lcii=round(bcllii);
		ucii=floor(bcucii)+1;
		if ((lcii < 1) | (ucii > samples)) then;do;
		  runnotes[4,1]=4;criterr=1;lcii=1;ucii=samples;
		end;
		bootllci[1,i]=bootsort[lcii,i];
		bootulci[1,i]=bootsort[ucii,i];
	  end;
	end;
	if (bc ^= 1) then;do;
      bootllci=bootsort[lcii,];
	  bootulci=bootsort[ucii,];
	end;
	bootci=bootllci`||bootulci`;
	bootres=indres||seboots||bootci;
  end; 
  if ((&contrast = 1) & (mpairs > 1)) then;do; *2;
    bccicont=j(4,ncol(contsamp),0);
	contsort=contsamp;
	contllci=j(1,ncol(contsamp),0);
	contulci=j(1,ncol(contsamp),0);
    do i = 1 to ncol(contsamp);
      tttt=contsamp[,i];
      contgrad=rank(tttt);
      contsort[contgrad,i]=tttt;
      tempmn=tttt[+,]/samples;
      tempsm=(tttt[,1]-tempmn)##2;contres[i,2]=sqrt(tempsm[+,]/(samples-1));
	  contsam2=contres[i,1]//contsamp[,i];
	  contgra2=rank(contsam2);
	  if (bc=1) then;do;

	    ttttt=contsamp[,i];
        tttt=(ttttt < contres[i,1]);bccicont[1,i]=tttt[+,]/samples;
        bccicont[2,i]=bccicont[1,i];
		if (bccicont[1,i] > .5) then;do;bccicont[2,i]=1-bccicont[1,i];end;
		bccicont[3,i]=sqrt(-2*log(bccicont[2,i]));
	    tttt=bccicont[3,i];
        bccicont[4,i]=tttt+((((tttt*p4+p3)*tttt+p2)*tttt+p1)*tttt+p0)/((((tttt*q4+q3)*tttt+q2)*tttt+q1)*tttt+q0);
        if (bccicont[1,i] <= 0.5) then;do;bccicont[4,i]=-bccicont[4,i];end;
        cbcllii=probnorm(2*bccicont[4,i]-zalpha2)*samples;
		cbcucii=probnorm(2*bccicont[4,i]+zalpha2)*samples;
		lcii=round(cbcllii);
		ucii=floor(cbcucii)+1;
		if ((lcii < 1) | (ucii > samples)) then;do;
          runnotes[4,1]=4;lcii=1;ucii=samples;
		end;
		contllci[1,i]=contsort[lcii,i];
		contulci[1,i]=contsort[ucii,i];
	  end;
	end; 
    if (bc ^= 1) then;do;
	  contllci=contsort[lcii,];
	  contulci=contsort[ucii,];
	end;
	contci=contllci`||contulci`;
	contres[,3:4]=contci;
  end; *2;
end; *1; 

print "************************ MEMORE Procedure for SAS Beta Release *************************";
print "Written by Amanda K. Montoya and Andrew F. Hayes";
print "Documentation available at afhayes.com";
print "****************************************************************************************";
if (criterr = 0) then;do; 
  varrlabs={"Y = " "M1 = " "M2 = " "M3 = " "M4 = " "M5 = " "M5 = " "M5 = " "M6 = " "M7 = " "M8 = " "M9 = " "M10 = "};
  if (mpairs=1) then;do;
    varrlabs={"Y = " "M = "};
  end;
  tttt=ynames//mnamemat;
  print tttt [label = "Variables:" rowname=varrlabs];  
  compname=" "||ynames[1,1]||" - "||ynames[1,2]||" "||" "||" ";
  do j = 1 to mpairs;
    tttt=" "||mnamemat[j,1]||" - "||mnamemat[j,2]||" "||" "||" ";
    compname=compname//tttt;
  end;
  do j = 1 to mpairs;
	tttt="("||mnamemat[j,1]||" + "||mnamemat[j,2]||")"||"/2"||"centered";
	compname=compname//tttt;
  end;
  temp1={"M1diff = " "M2diff = " "M3diff = " "M4diff = " "M5diff = " "M6diff = " "M7diff = " "M8diff = " "M9diff = " "M10diff = "};
  temp2={"M1avg = " "M2avg = " "M3avg = " "M4avg = " "M5avg = " "M6avg = " "M7avg = " "M8avg = " "M9avg = " "M10avg = "};
  temprnam={"Ydiff = " "Mdiff = " "Mavg = "};
  if (mpairs ^= 1) then;do;
    temprnam="Ydiff = "||temp1[1,1:mpairs]||temp2[1,1:mpairs];
  end;
  print compname [label="Computed Variables:" rowname=temprnam];
  print n [label="Sample Size:"];
  if (&seed ^= 0) then;do;
    seedt=&seed;
	print seedt [label = "Custom seed:"];
  end;
  print "****************************************************************************************";
  collab="Effect"||"SE"||"t"||"df"||"p"||"LLCI"||"ULCI";
  rowlab="c";
  print cresmat [label = "Effect of X on Y difference" rowname=rowlab colname = collab format=&decimals];
  print "****************************************************************************************";
  alabs = {"a1" "a2" "a3" "a4" "a5" "a6" "a7" "a8" "a9" "a10"};
  pairlabs="a";
  if (mpairs ^= 1) then;do;
    pairlabs=alabs[1,1:mpairs];
  end;
  print aresmat [label = "Effect of X on M difference(s):" rowname = pairlabs colname=collab format=&decimals];
  print "****************************************************************************************";
  ylab="Ydiff = "||ynames[1,1]||" - "||ynames[1,2];
  print ylab [label="Outcome:"];
  modsumr=Rfull||Rsqfull||MSR||Ffull||df1||df2||pfull;
  clab="R"||"R-sq"||"MSE"||"F"||"df1"||"df2"||"p";
    collab="Effect"||"SE"||"t"||"df"||"p"||"LLCI"||"ULCI";
  print modsumr [label="Model Summary" colname=clab format = &decimals];
  modres=cpresmat//bresmat//dresmat;
  bdlabs = {"b1" "b2" "b3" "b4" "b5" "b6" "b7" "b8" "b9" "b10"};
  bslabs = {"d1" "d2" "d3" "d4" "d5" "d6" "d7" "d8" "d9" "d10"};
  modlabs="c'"||"b"||"d";
  if (mpairs ^= 1) then;do;
    modlabs = "c'"||bdlabs[1,1:mpairs]||bslabs[1,1:mpairs];
  end;
  print modres [label = "Model" rowname = modlabs colname=collab format = &decimals];
 print "*********************** TOTAL, DIRECT, AND INDIRECT EFFECTS *****************************";
   collab="Effect"||"SE"||"t"||"df"||"p"||"LLCI"||"ULCI";
 rowlab="c";
 print cresmat [label = "Total effect of X on Y" rowname = rowlab colname=collab format = &decimals];
 rowlab="c'";
 print cpresmat [label = "Direct effect of X on Y" rowname = rowlab colname=collab format = &decimals];
 if (mc = 1) then;do;
   indlabs = {"Effect" "MCSE" "MC LLCI" "MC ULCI"};
   indres=mcres;
 end;
 if (mc ^= 1) then;do;
   indlabs = {"Effect" "Boot SE" "BootLLCI" "BootULCI"};
   indres=bootres;
 end;
 mlab="ab";
 if (mpairs ^= 1) then;do;
   mlab = {"a1b1" "a2b2" "a3b3" "a4b4" "a5b5" "a6b6" "a7b7" "a8b8" "a9b9" "a10b10"};
 end;
 m2lab=mlab[1,1:mpairs]||"Total";
 if (mpairs = 1) then;do;
   indres=indres[1,];
 end;
 print indres [label="Indirect Effect of X on Y through M" rowname=m2lab colname=indlabs format = &decimals];
 if (&normal = 1) then;do;
   clab={"Effect" "SE" "Z" "p"};
   print normres [label = "Normal Theory Test for Indirect Effect" rowname=mlab colname=clab format=&decimals];
 end;
 if ((&contrast=1) & (mpairs > 1)) then;do;
  contlab="(C1)"//"(C2)"//"(C3)"//"(C4)"//"(C5)"//"(C6)"//"(C7)"//"(C8)"//"(C9)"//"(C10)";
  contlab=contlab//"(C11)"//"(C12)"//"(C13)"//"(C14)"//"(C15)"//"(C16)"//"(C17)"//"(C18)"//"(C19)"//"(C20)";
  contlab=contlab//"(C21)"//"(C22)"//"(C23)"//"(C24)"//"(C25)"//"(C26)"//"(C27)"//"(C28)"//"(C29)"//"(C30)";
  contlab=contlab//"(C31)"//"(C32)"//"(C33)"//"(C34)"//"(C35)"//"(C36)"//"(C37)"//"(C38)"//"(C39)"//"(C40)";
  contlab=contlab//"(C41)"//"(C42)"//"(C43)"//"(C44)"//"(C45)";
  print contres [label="Pairwise Contrasts Between Specific Indirect Effects" rowname=contlab colname=indlabs format=&decimals];
  contkey = " "||" "||" ";
  do i = 1 to mpairs-1;
    do j = i+1 to mpairs;
	  tttt=mlab[1,i]||" - "|| mlab[1,j];
	  contkey=contkey//tttt;
	end;
  end;
  contkey=contkey[2:nrow(contkey),];
  print contkey [label = "Contrast definitions:" rowname = contlab];
 end;
end; 
print "*************************** ANALYSIS NOTES AND WARNINGS ******************************";
print "Check SAS log for errors.  Do not interpret output if errors are found.";
do i = 1 to 10;
  if (runnotes[i,1]=1) then;do;
    print missing [label="NOTE: Somecases were deleted due to missing data.  The number of cases was:"];
  end;
  if (runnotes[i,1]=2) then;do;
    print "ERROR: Exactly two Y variables must be provided in the Y= list.";
  end;
  if (runnotes[i,1]=3) then;do;
    print samples [label="NOTE: An invalid number of samples was specified.  The number of samples used was:"];
  end;
  if (runnotes[i,1]=4) then;do;
    print "ERROR: The number of samples specified is insufficient for desired confidence.";
	print "Please increase the number of samples or decrease confidence.";
	tttt=conf||samples;
	print tttt [label="Confidence and samples specified:"];
  end;
  if (runnotes[i,1]=5) then;do;
    print "NOTE: The confidence specified was not between 50 and 99.99.  Level of confidence";
	print "was adjusted to 95%:";
  end;
  if (runnotes[i,1]=6) then;do;
    print "ERROR: An even number of variables is required in the M= list.";
  end;
  if (runnotes[i,1]=7) then;do;
    print copyname [label = "ERROR: Two of the specified variables are copies.  The variable names are:"];
  end;
  if (runnotes[i,1]=8) then;do;
    print "ERROR: All specified variables must be unique. No variables may be the same in M and Y.";
  end;
  if (runnotes[i,1]=9) then;do;
    print "NOTE: Both Monte Carlo and bootstrap methods were requested.  Only Monte Carlo CI is provided.";
  end;
  if (runnotes[i,1]=10) then;do;
    print "NOTE: Contrast cannot be constructed with only one pair of mediators.";
  end;
end;

if (criterr=0) then;do;
  if ((mc ^= 1) & (bc = 1)) then;do;
    print "Bootstrap confidence interval method: Bias corrected";
  end;
  if ((mc ^= 1) & (bc ^= 1)) then;do;
    print "Bootstrap confidence interval method: Percentile";
  end;
  if (mc = 1) then;do;
    print samples [label="Number of samples for Monte Carlo confidence intervals:"];
  end;
  if (mc ^= 1) then;do;
    print samples [label="Number of samples for bootstrap confidence intervals:"];
  end;
  print conf [label = "Level of confidence for all confidence intervals in output:"];
  
  savelab=" ";
  do i=1 to mpairs;
    if (mpairs = 1) then;do;
      savelab=savelab||"a"||"b"||"ab"||"TotalInd";
    end;
    if (mpairs ^= 1) then;do;
      savelab=savelab||alabs[1,i]||bdlabs[1,i]||mlab[1,i];
      if (i=mpairs) then;do;
	    savelab=savelab||"TotalInd";
	  end;
    end;
  end;
  savelab=savelab[1,(2:ncol(savelab))];
  if ((savboot=1) & (mc = 1)) then;do;
    create &save from mcsave [colname=savelab];
    append from mcsave;
  end;
  if ((savboot=1) & (mc ^= 1)) then;do;
    savelab=savelab||"c'"||"c";
    create &save from bootsave [colname=savelab];
    append from bootsave;
  end;
end;
quit;
%mend;

